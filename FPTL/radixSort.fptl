Scheme RadixSort
{
  N = 10000;

	Array = (("./" * N.toString * ".txt").add * N.EmptyArray).openFile.([:] -> [1], print);	
    EmptyArray = ([1] * 0).arrayCreate;

  MaxNum = (Array * 0 * 0).findMax;

  @ = (Array * 0 * 1 * MaxNum).Sort.print;

  Fun Sort{
    Array = [1];
    posValue = [2];
    Rank = [3];
    MaxNum = [4];

    @ = ((MaxNum * Rank).div * 0).greater -> ((Array * posValue * Rank * 0).ReorderBuckets * (Rank * 10).mul * MaxNum).Sort, Array;

    Fun ReorderBuckets{
      Array = [1];
      posValue = [2];
      Rank = [3];
      i = [4];

      @ = (i * 10).less -> ((Array * posValue * Rank * i * 0).ReorderByDigit * Rank * (i * 1).add * 0).ReorderBuckets,
          (i * 10).equal -> (Array * 0);

      Fun ReorderByDigit{
        Array = [1];
        posValue = [2];
        Rank = [3];
        i = [4];
        j = [5];

        CurrentNumber = (Array * j).arrayGet;
        SwappedArray = (Array * posValue * j).Swap;
        IncPosArray = (SwappedArray * (posValue * 1).add);

        @ = (j * Array.arrayLen).equal -> (Array * posValue),
            ((j * Array.arrayLen).less * ((CurrentNumber * Rank * 1).getDigit * i).equal).and -> (IncPosArray * Rank * i * (j * 1).add).ReorderByDigit,
            ((j * Array.arrayLen).less * ((CurrentNumber * Rank * 1).getDigit * i).nequal).and -> (Array * posValue * Rank * i * (j * 1).add).ReorderByDigit;

        Fun Swap{
          Array = [1];
          i = [2];
          j = [3];

          @ = (Array * i * j * (Array * i).arrayGet * (Array * j).arrayGet).TempSwap;

          Fun TempSwap{
            Array = [1];
            i = [2];
            j = [3];
            first = [4];
            second = [5];
            
            @ = ((Array * i * second).arraySet * j * first).arraySet;
          }
        }
        Fun getDigit{
          Number = [1];
          Rank = [2];
          Counter = [3];
          
          @ = ((Number * 0).greater * (Rank * Counter).nequal).and -> ((Number * 10).div * Rank * (Counter * 10).mul).getDigit,
              (Number * 10).mod;
        }
      }
    }
  }
  Fun findMax{
    array = [1];
    max = [2];
    currIndex = [3];

    @ = (array.arrayLen  * 0).equal -> -1,
        ((array.arrayLen  * 1).sub * currIndex).equal -> ((array * currIndex).arrayGet * max).getMaxOf.toInt,
        (array.arrayLen  * 1).greater -> (array * ((array * currIndex).arrayGet * max).getMaxOf * (currIndex * 1).add).findMax;
  }
  Fun getMaxOf{
    @ = ([1] * [2]).greater -> [1], [2];
  }
}
Application
%RadixSort