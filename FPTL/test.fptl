Scheme RadixSort
{
  P = [1].toInt;
  N = [2].toInt;
  Max = 10;

	Array = (("./" * N.toString * ".txt").add * N.EmptyArray).openFile.([:] -> [1], print);	
    EmptyArray = ([1] * 0).arrayCreate;

  Fun RandomIntArray{
    Size = [1];
    Max = [2];

    EmptyArray = (1 * 0).arrayCreate;

    @ = (EmptyArray * Size * Max * 0).createRandomArray;

    Fun createRandomArray{
      Array = [1];
      Size = [2];
      Max = [3];
      i = [4];

      RandomNumber = Max.RandomInt;
      RandomNumberArray = (1 * RandomNumber).arrayCreate;

      @ = (i * 0).equal -> (RandomNumberArray * Size * Max * (i * 1).add).createRandomArray,
          (i * Size).less -> ((Array * RandomNumberArray).arrayCat * Size * Max * (i * 1).add).createRandomArray,
          (i * Size).equal -> Array;

      Fun RandomInt{
        Max = [1];
        @ = (rand * Max.toReal).mul.toInt;
      }
    }
  }

  @ = (N * Array).CombineSorts.print;

  Fun CombineSorts{
    N = [1];
    Array = [2];

    MaxNum = (Array * 0 * 0).findMax;

    Fun findMax{
      array = [1];
      max = [2];
      currIndex = [3];

      @ = (array.arrayLen  * 0).equal -> -1,
          ((array.arrayLen  * 1).sub * currIndex).equal -> ((array * currIndex).arrayGet * max).getMaxOf.toInt,
          (array.arrayLen  * 1).greater -> (array * ((array * currIndex).arrayGet * max).getMaxOf * (currIndex * 1).add).findMax;
    }
    Fun getMaxOf{
      @ = ([1] * [2]).greater -> [1], [2];
    }

    @ = (N * Array * MaxNum * 2 * 9).SortDigits;
  }

  Fun SortDigits{
    N = [1];
    Array = [2];
    MaxNum = [3];
    StartIndex = [4];
    EndIndex = [5];

    @ = (N * 1).equal -> Array,
        (Array * 0 * 1 * MaxNum * StartIndex * EndIndex).Sort;

    Fun Sort{
      Array = [1];
      posValue = [2];
      Rank = [3];
      MaxNum = [4];
      startIndex = [5];
      endIndex = [6];

      @ = ((MaxNum * Rank).div * 0).greater -> ((Array * posValue * Rank * 0 * startIndex * endIndex).ReorderBuckets * (Rank * 10).mul * MaxNum * startIndex * endIndex).Sort, Array;

      Fun ReorderBuckets{
        Array = [1];
        posValue = [2];
        Rank = [3];
        i = [4];
        startIndex = [5];
        endIndex = [6];

        @ = (i * 10).less -> ((Array * posValue * Rank * i * startIndex * endIndex).ReorderByDigit * Rank * (i * 1).add * startIndex * endIndex).ReorderBuckets,
            (i * 10).equal -> (Array * 0);

        Fun ReorderByDigit{
          Array = [1];
          posValue = [2];
          Rank = [3];
          i = [4];
          j = [5];
          endIndex = [6];

          CurrentNumber = (Array * j).arrayGet;
          SwappedArray = (Array * posValue * j).Swap;
          IncPosArray = (SwappedArray * (posValue * 1).add);

          @ = (j * (endIndex * 1).add).equal -> (Array * posValue),
              ((j * endIndex).lequal * ((CurrentNumber * Rank * 1).getDigit * i).equal).and -> (IncPosArray * Rank * i * (j * 1).add * endIndex).ReorderByDigit,
              ((j * endIndex).lequal * ((CurrentNumber * Rank * 1).getDigit * i).nequal).and -> (Array * posValue * Rank * i * (j * 1).add * endIndex).ReorderByDigit;

          Fun Swap{
            Array = [1];
            i = [2];
            j = [3];

            @ = (Array * i * j * (Array * i).arrayGet * (Array * j).arrayGet).TempSwap;

            Fun TempSwap{
              Array = [1];
              i = [2];
              j = [3];
              first = [4];
              second = [5];
              
              @ = ((Array * i * second).arraySet * j * first).arraySet;
            }
          }
          Fun getDigit{
            Number = [1];
            Rank = [2];
            Counter = [3];
            
            @ = ((Number * 0).greater * (Rank * Counter).nequal).and -> ((Number * 10).div * Rank * (Counter * 10).mul).getDigit,
                (Number * 10).mod;
          }
        }
      }
    }
  }
}
Application
%RadixSort(8, 10)