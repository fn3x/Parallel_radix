Scheme Sort
{
  N = 10000;
	P = 8;

	Array = (("./" * N.toString * ".txt").add * N.EmptyArray).openFile.([:] -> [1], print);	
    EmptyArray = ([1] * 0).arrayCreate;

  MaxNum = (Array * 0 * 0).findMax;

  @ = (Array * 1 * MaxNum).RadixSort.print;

  Fun RadixSort{
    Array = [1];
    Rank = [2];
    MaxNum = [3];
    AugArray = (Rank * 1).equal -> (Array * (1 * 0).arrayCreate).arrayCat, Array;

    @ = ((MaxNum * Rank).div * 0).greater -> ((AugArray * Rank * 0).ReorderBuckets * (Rank * 10).mul * MaxNum).RadixSort, AugArray;

    Fun ReorderBuckets{
      AugArray = [1];
      Rank = [2];
      i = [3];

      posIndex = (AugArray.arrayLen * 1).sub;
      posValue = (AugArray * posIndex).arrayGet;

      @ = (i * 10).less -> ((AugArray * Rank * i * 0).ReorderByDigit * Rank * (i * 1).add * 0).ReorderBuckets,
          (i * 10).equal -> (AugArray * (AugArray.arrayLen * 1).sub * 0).arraySet;

      Fun ReorderByDigit{
        AugArray = [1];
        Rank = [2];
        i = [3];
        j = [4];

        CurrentNumber = (AugArray * j).arrayGet;
        SwappedArray = (AugArray * posValue * j).Swap;
        IncPosArray = (SwappedArray * posIndex * (posValue * 1).add).arraySet;
        posIndex = (AugArray.arrayLen * 1).sub;
        posValue = (AugArray * posIndex).arrayGet;

        @ = ((j * (AugArray.arrayLen * 1).sub).less * ((CurrentNumber * Rank * 1).getDigit * i).equal).and -> (IncPosArray * Rank * i * (j * 1).add).ReorderByDigit,
            ((j * (AugArray.arrayLen * 1).sub).less * ((CurrentNumber * Rank * 1).getDigit * i).nequal).and -> (AugArray * Rank * i * (j * 1).add).ReorderByDigit,
            (j * (AugArray.arrayLen * 1).sub).equal -> AugArray;

        Fun Swap{
          Array = [1];
          i = [2];
          j = [3];

          @ = (Array * i * j * (Array * i).arrayGet * (Array * j).arrayGet).TempSwap;

          Fun TempSwap{
            Array = [1];
            i = [2];
            j = [3];
            first = [4];
            second = [5];
            
            @ = ((Array * i * second).arraySet * j * first).arraySet;
          }
        }
        Fun getDigit{
          Number = [1];
          Rank = [2];
          Counter = [3];
          
          @ = ((Number * 0).greater * (Rank * Counter).nequal).and -> ((Number * 10).div * Rank * (Counter * 10).mul).getDigit,
              (Number * 10).mod;
        }
      }
    }
  }
  Fun findMax{
    array = [1];
    max = [2];
    currIndex = [3];

    @ = (array.arrayLen  * 0).equal -> -1,
        ((array.arrayLen  * 1).sub * currIndex).equal -> ((array * currIndex).arrayGet * max).getMaxOf.toInt,
        (array.arrayLen  * 1).greater -> (array * ((array * currIndex).arrayGet * max).getMaxOf * (currIndex * 1).add).findMax;
  }
  Fun getMaxOf{
    @ = ([1] * [2]).greater -> [1], [2];
  }
}
Application
%Sort